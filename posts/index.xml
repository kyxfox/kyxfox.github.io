<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Posts on Kyxfox</title>
    <link>https://kyxfox.com/posts/</link>
    <description>Recent content in Posts on Kyxfox</description>
    <generator>Hugo -- 0.139.3</generator>
    <language>en</language>
    <lastBuildDate>Sat, 21 Dec 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://kyxfox.com/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Resolving update issue for bi-directional relationship models</title>
      <link>https://kyxfox.com/posts/ios-development/resolving-update-issue-for-bi-directional-relationship-models/</link>
      <pubDate>Sat, 21 Dec 2024 00:00:00 +0000</pubDate>
      <guid>https://kyxfox.com/posts/ios-development/resolving-update-issue-for-bi-directional-relationship-models/</guid>
      <description>&lt;h2 id=&#34;problem-overview&#34;&gt;&lt;strong&gt;Problem Overview&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;While developing an iOS music player app, I encountered an issue where adding a song to a new playlist inadvertently removed it from its original playlist. This occurred due to incorrect management of bi-directional relationships between songs and playlists.&lt;/p&gt;
&lt;p&gt;The relationship setup:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A &lt;code&gt;MusicModel&lt;/code&gt; represents a song and has a &lt;code&gt;playlists&lt;/code&gt; property linking to the playlists it belongs to.&lt;/li&gt;
&lt;li&gt;A &lt;code&gt;PlaylistModel&lt;/code&gt; represents a playlist and has a &lt;code&gt;songs&lt;/code&gt; property linking to its songs.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;original-code&#34;&gt;&lt;strong&gt;Original Code&lt;/strong&gt;&lt;/h2&gt;
&lt;h3 id=&#34;adding-songs-to-a-playlist&#34;&gt;Adding Songs to a Playlist&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;private func addSelectedSongs() {
    let songsToAdd = allSongs.filter { selectedSongs.contains($0.id) }
    for song in songsToAdd {
        playlist.songs.append(song)
        song.playlists.append(playlist)
    }
    playlist.updatedAt = Date()
    try? modelContext.save()
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;removing-songs-from-a-playlist&#34;&gt;Removing Songs from a Playlist&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;private func removeSong(_ song: MusicModel) {
    playlist.songs.removeAll { $0.id == song.id }
    song.playlists.removeAll { $0.id == playlist.id }
    playlist.updatedAt = Date()
    try? modelContext.save()
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;issue-with-the-original-code&#34;&gt;Issue with the Original Code&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Direct Modification of Relationships:&lt;/strong&gt; Adding a playlist to a song (&lt;code&gt;song.playlists.append(playlist)&lt;/code&gt;) unintentionally overwrote existing playlist associations.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;updated-code&#34;&gt;&lt;strong&gt;Updated Code&lt;/strong&gt;&lt;/h2&gt;
&lt;h3 id=&#34;updatedaddselectedsongs&#34;&gt;Updated &lt;code&gt;addSelectedSongs&lt;/code&gt;&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;private func addSelectedSongs() {
    let songsToAdd = allSongs.filter { selectedSongs.contains($0.id) }
    for song in songsToAdd {
        // Ensure the song is not already in the playlist
        if !playlist.songs.contains(where: { $0.id == song.id }) {
            playlist.songs.append(song)
        }

        // Ensure the playlist is not already in the song
        if !song.playlists.contains(where: { $0.id == playlist.id }) {
            song.playlists.append(playlist)
        }
    }
    playlist.updatedAt = Date()
    try? modelContext.save()
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;updatedremovesong&#34;&gt;Updated &lt;code&gt;removeSong&lt;/code&gt;&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;private func removeSong(_ song: MusicModel) {
    // Remove the song from the current playlist
    playlist.songs.removeAll { $0.id == song.id }

    // Remove the current playlist from the song
    song.playlists.removeAll { $0.id == playlist.id }

    playlist.updatedAt = Date()
    try? modelContext.save()
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;idea-to-fix-the-issue&#34;&gt;Idea to fix the issue&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Preserves Existing Associations:&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;The updated &lt;code&gt;addSelectedSongs&lt;/code&gt; method checks if the song or playlist already exists in the relationship before appending. This prevents overwriting existing associations.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Scoped Removal:&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;The updated &lt;code&gt;removeSong&lt;/code&gt; method only removes the current playlist from the song’s &lt;code&gt;playlists&lt;/code&gt;, ensuring other playlist associations remain intact.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ensures Data Integrity:&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;The changes ensure that a song can belong to multiple playlists simultaneously without any unintended side effects.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    <item>
      <title>Introduction of CORS</title>
      <link>https://kyxfox.com/posts/cybersecurity/introduction-of-cors/</link>
      <pubDate>Thu, 21 Dec 2023 00:00:00 +0000</pubDate>
      <guid>https://kyxfox.com/posts/cybersecurity/introduction-of-cors/</guid>
      <description>&lt;h3 id=&#34;summary&#34;&gt;Summary&lt;/h3&gt;
&lt;p&gt;Cross-origin resource sharing (CORS) is a browser mechanism which enables controlled access to resources located outside of a given domain. It extends and adds flexibility to the same-origin policy (SOP).&lt;/p&gt;
&lt;h4 id=&#34;access-control-allow-origin&#34;&gt;Access-Control-Allow-Origin&lt;/h4&gt;
&lt;p&gt;#ACAO
&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; header is included in the response from one website to a request originating from another website, and identifies the permitted origin of the request.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;GET /data HTTP/1.1
Host: robust-website.com
Origin : https://normal-website.com
------------------------------------------------------------------
HTTP/1.1 200 OK
...
Access-Control-Allow-Origin: https://normal-website.com
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;access-control-allow-credentials&#34;&gt;Access-Control-Allow-Credentials&lt;/h4&gt;
&lt;p&gt;#ACAC
The default behavior of cross-origin resource requests is for requests to be passed without credentials like cookies and the Authorization header. However, the cross-domain server can permit reading of the response when credentials are passed to it by setting the CORS &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; header to true.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Introduction of CSRF</title>
      <link>https://kyxfox.com/posts/cybersecurity/introduction-of-csrf/</link>
      <pubDate>Thu, 21 Dec 2023 00:00:00 +0000</pubDate>
      <guid>https://kyxfox.com/posts/cybersecurity/introduction-of-csrf/</guid>
      <description>&lt;h3 id=&#34;summary&#34;&gt;Summary&lt;/h3&gt;
&lt;p&gt;Cross-site request forgery (also known as CSRF) is a web security vulnerability that allows an attacker to induce users to perform actions that they do not intend to perform. It allows an attacker to partly circumvent the same origin policy, which is designed to prevent different websites from interfering with each other.&lt;/p&gt;
&lt;h4 id=&#34;samesite-cookies&#34;&gt;SameSite cookies&lt;/h4&gt;
&lt;p&gt;#SameSite
SameSite is a browser security mechanism that determines when a website&amp;rsquo;s cookies are included in requests originating from other websites.
In the context of SameSite cookie restrictions, a site is defined as the top-level domain (TLD), usually something like &lt;code&gt;.com&lt;/code&gt; or &lt;code&gt;.net&lt;/code&gt;, plus one additional level of the domain name. This is often referred to as the TLD+1.
When determining whether a request is same-site or not, the URL scheme is also taken into consideration. This means that a link from &lt;code&gt;http://app.example.com&lt;/code&gt; to &lt;code&gt;https://app.example.com&lt;/code&gt; is treated as cross-site by most browsers.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
