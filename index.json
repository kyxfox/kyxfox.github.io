[{"content":"Problem Overview While developing an iOS music player app, I encountered an issue where adding a song to a new playlist inadvertently removed it from its original playlist. This occurred due to incorrect management of bi-directional relationships between songs and playlists.\nThe relationship setup:\nA MusicModel represents a song and has a playlists property linking to the playlists it belongs to. A PlaylistModel represents a playlist and has a songs property linking to its songs. Original Code Adding Songs to a Playlist private func addSelectedSongs() { let songsToAdd = allSongs.filter { selectedSongs.contains($0.id) } for song in songsToAdd { playlist.songs.append(song) song.playlists.append(playlist) } playlist.updatedAt = Date() try? modelContext.save() } Removing Songs from a Playlist private func removeSong(_ song: MusicModel) { playlist.songs.removeAll { $0.id == song.id } song.playlists.removeAll { $0.id == playlist.id } playlist.updatedAt = Date() try? modelContext.save() } Issue with the Original Code Direct Modification of Relationships: Adding a playlist to a song (song.playlists.append(playlist)) unintentionally overwrote existing playlist associations. Updated Code Updated addSelectedSongs private func addSelectedSongs() { let songsToAdd = allSongs.filter { selectedSongs.contains($0.id) } for song in songsToAdd { // Ensure the song is not already in the playlist if !playlist.songs.contains(where: { $0.id == song.id }) { playlist.songs.append(song) } // Ensure the playlist is not already in the song if !song.playlists.contains(where: { $0.id == playlist.id }) { song.playlists.append(playlist) } } playlist.updatedAt = Date() try? modelContext.save() } Updated removeSong private func removeSong(_ song: MusicModel) { // Remove the song from the current playlist playlist.songs.removeAll { $0.id == song.id } // Remove the current playlist from the song song.playlists.removeAll { $0.id == playlist.id } playlist.updatedAt = Date() try? modelContext.save() } Idea to fix the issue Preserves Existing Associations: The updated addSelectedSongs method checks if the song or playlist already exists in the relationship before appending. This prevents overwriting existing associations. Scoped Removal: The updated removeSong method only removes the current playlist from the song’s playlists, ensuring other playlist associations remain intact. Ensures Data Integrity: The changes ensure that a song can belong to multiple playlists simultaneously without any unintended side effects. ","permalink":"https://kyxfox.com/posts/abc/","summary":"\u003ch2 id=\"problem-overview\"\u003e\u003cstrong\u003eProblem Overview\u003c/strong\u003e\u003c/h2\u003e\n\u003cp\u003eWhile developing an iOS music player app, I encountered an issue where adding a song to a new playlist inadvertently removed it from its original playlist. This occurred due to incorrect management of bi-directional relationships between songs and playlists.\u003c/p\u003e\n\u003cp\u003eThe relationship setup:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eA \u003ccode\u003eMusicModel\u003c/code\u003e represents a song and has a \u003ccode\u003eplaylists\u003c/code\u003e property linking to the playlists it belongs to.\u003c/li\u003e\n\u003cli\u003eA \u003ccode\u003ePlaylistModel\u003c/code\u003e represents a playlist and has a \u003ccode\u003esongs\u003c/code\u003e property linking to its songs.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"original-code\"\u003e\u003cstrong\u003eOriginal Code\u003c/strong\u003e\u003c/h2\u003e\n\u003ch3 id=\"adding-songs-to-a-playlist\"\u003eAdding Songs to a Playlist\u003c/h3\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eprivate func addSelectedSongs() {\n    let songsToAdd = allSongs.filter { selectedSongs.contains($0.id) }\n    for song in songsToAdd {\n        playlist.songs.append(song)\n        song.playlists.append(playlist)\n    }\n    playlist.updatedAt = Date()\n    try? modelContext.save()\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"removing-songs-from-a-playlist\"\u003eRemoving Songs from a Playlist\u003c/h3\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eprivate func removeSong(_ song: MusicModel) {\n    playlist.songs.removeAll { $0.id == song.id }\n    song.playlists.removeAll { $0.id == playlist.id }\n    playlist.updatedAt = Date()\n    try? modelContext.save()\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"issue-with-the-original-code\"\u003eIssue with the Original Code\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eDirect Modification of Relationships:\u003c/strong\u003e Adding a playlist to a song (\u003ccode\u003esong.playlists.append(playlist)\u003c/code\u003e) unintentionally overwrote existing playlist associations.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"updated-code\"\u003e\u003cstrong\u003eUpdated Code\u003c/strong\u003e\u003c/h2\u003e\n\u003ch3 id=\"updatedaddselectedsongs\"\u003eUpdated \u003ccode\u003eaddSelectedSongs\u003c/code\u003e\u003c/h3\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eprivate func addSelectedSongs() {\n    let songsToAdd = allSongs.filter { selectedSongs.contains($0.id) }\n    for song in songsToAdd {\n        // Ensure the song is not already in the playlist\n        if !playlist.songs.contains(where: { $0.id == song.id }) {\n            playlist.songs.append(song)\n        }\n\n        // Ensure the playlist is not already in the song\n        if !song.playlists.contains(where: { $0.id == playlist.id }) {\n            song.playlists.append(playlist)\n        }\n    }\n    playlist.updatedAt = Date()\n    try? modelContext.save()\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"updatedremovesong\"\u003eUpdated \u003ccode\u003eremoveSong\u003c/code\u003e\u003c/h3\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eprivate func removeSong(_ song: MusicModel) {\n    // Remove the song from the current playlist\n    playlist.songs.removeAll { $0.id == song.id }\n\n    // Remove the current playlist from the song\n    song.playlists.removeAll { $0.id == playlist.id }\n\n    playlist.updatedAt = Date()\n    try? modelContext.save()\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"idea-to-fix-the-issue\"\u003eIdea to fix the issue\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003ePreserves Existing Associations:\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003eThe updated \u003ccode\u003eaddSelectedSongs\u003c/code\u003e method checks if the song or playlist already exists in the relationship before appending. This prevents overwriting existing associations.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eScoped Removal:\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003eThe updated \u003ccode\u003eremoveSong\u003c/code\u003e method only removes the current playlist from the song’s \u003ccode\u003eplaylists\u003c/code\u003e, ensuring other playlist associations remain intact.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eEnsures Data Integrity:\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003eThe changes ensure that a song can belong to multiple playlists simultaneously without any unintended side effects.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e","title":"Resolving update issue for bi-directional relationship models"},{"content":"Problem Overview While developing an iOS music player app, I encountered an issue where adding a song to a new playlist inadvertently removed it from its original playlist. This occurred due to incorrect management of bi-directional relationships between songs and playlists.\nThe relationship setup:\nA MusicModel represents a song and has a playlists property linking to the playlists it belongs to. A PlaylistModel represents a playlist and has a songs property linking to its songs. Original Code Adding Songs to a Playlist private func addSelectedSongs() { let songsToAdd = allSongs.filter { selectedSongs.contains($0.id) } for song in songsToAdd { playlist.songs.append(song) song.playlists.append(playlist) } playlist.updatedAt = Date() try? modelContext.save() } Removing Songs from a Playlist private func removeSong(_ song: MusicModel) { playlist.songs.removeAll { $0.id == song.id } song.playlists.removeAll { $0.id == playlist.id } playlist.updatedAt = Date() try? modelContext.save() } Issue with the Original Code Direct Modification of Relationships: Adding a playlist to a song (song.playlists.append(playlist)) unintentionally overwrote existing playlist associations. Updated Code Updated addSelectedSongs private func addSelectedSongs() { let songsToAdd = allSongs.filter { selectedSongs.contains($0.id) } for song in songsToAdd { // Ensure the song is not already in the playlist if !playlist.songs.contains(where: { $0.id == song.id }) { playlist.songs.append(song) } // Ensure the playlist is not already in the song if !song.playlists.contains(where: { $0.id == playlist.id }) { song.playlists.append(playlist) } } playlist.updatedAt = Date() try? modelContext.save() } Updated removeSong private func removeSong(_ song: MusicModel) { // Remove the song from the current playlist playlist.songs.removeAll { $0.id == song.id } // Remove the current playlist from the song song.playlists.removeAll { $0.id == playlist.id } playlist.updatedAt = Date() try? modelContext.save() } Idea to fix the issue Preserves Existing Associations: The updated addSelectedSongs method checks if the song or playlist already exists in the relationship before appending. This prevents overwriting existing associations. Scoped Removal: The updated removeSong method only removes the current playlist from the song’s playlists, ensuring other playlist associations remain intact. Ensures Data Integrity: The changes ensure that a song can belong to multiple playlists simultaneously without any unintended side effects. ","permalink":"https://kyxfox.com/posts/ios-development/resolving-update-issue-for-bi-directional-relationship-models/","summary":"\u003ch2 id=\"problem-overview\"\u003e\u003cstrong\u003eProblem Overview\u003c/strong\u003e\u003c/h2\u003e\n\u003cp\u003eWhile developing an iOS music player app, I encountered an issue where adding a song to a new playlist inadvertently removed it from its original playlist. This occurred due to incorrect management of bi-directional relationships between songs and playlists.\u003c/p\u003e\n\u003cp\u003eThe relationship setup:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eA \u003ccode\u003eMusicModel\u003c/code\u003e represents a song and has a \u003ccode\u003eplaylists\u003c/code\u003e property linking to the playlists it belongs to.\u003c/li\u003e\n\u003cli\u003eA \u003ccode\u003ePlaylistModel\u003c/code\u003e represents a playlist and has a \u003ccode\u003esongs\u003c/code\u003e property linking to its songs.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"original-code\"\u003e\u003cstrong\u003eOriginal Code\u003c/strong\u003e\u003c/h2\u003e\n\u003ch3 id=\"adding-songs-to-a-playlist\"\u003eAdding Songs to a Playlist\u003c/h3\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eprivate func addSelectedSongs() {\n    let songsToAdd = allSongs.filter { selectedSongs.contains($0.id) }\n    for song in songsToAdd {\n        playlist.songs.append(song)\n        song.playlists.append(playlist)\n    }\n    playlist.updatedAt = Date()\n    try? modelContext.save()\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"removing-songs-from-a-playlist\"\u003eRemoving Songs from a Playlist\u003c/h3\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eprivate func removeSong(_ song: MusicModel) {\n    playlist.songs.removeAll { $0.id == song.id }\n    song.playlists.removeAll { $0.id == playlist.id }\n    playlist.updatedAt = Date()\n    try? modelContext.save()\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"issue-with-the-original-code\"\u003eIssue with the Original Code\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eDirect Modification of Relationships:\u003c/strong\u003e Adding a playlist to a song (\u003ccode\u003esong.playlists.append(playlist)\u003c/code\u003e) unintentionally overwrote existing playlist associations.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"updated-code\"\u003e\u003cstrong\u003eUpdated Code\u003c/strong\u003e\u003c/h2\u003e\n\u003ch3 id=\"updatedaddselectedsongs\"\u003eUpdated \u003ccode\u003eaddSelectedSongs\u003c/code\u003e\u003c/h3\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eprivate func addSelectedSongs() {\n    let songsToAdd = allSongs.filter { selectedSongs.contains($0.id) }\n    for song in songsToAdd {\n        // Ensure the song is not already in the playlist\n        if !playlist.songs.contains(where: { $0.id == song.id }) {\n            playlist.songs.append(song)\n        }\n\n        // Ensure the playlist is not already in the song\n        if !song.playlists.contains(where: { $0.id == playlist.id }) {\n            song.playlists.append(playlist)\n        }\n    }\n    playlist.updatedAt = Date()\n    try? modelContext.save()\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"updatedremovesong\"\u003eUpdated \u003ccode\u003eremoveSong\u003c/code\u003e\u003c/h3\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eprivate func removeSong(_ song: MusicModel) {\n    // Remove the song from the current playlist\n    playlist.songs.removeAll { $0.id == song.id }\n\n    // Remove the current playlist from the song\n    song.playlists.removeAll { $0.id == playlist.id }\n\n    playlist.updatedAt = Date()\n    try? modelContext.save()\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"idea-to-fix-the-issue\"\u003eIdea to fix the issue\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003ePreserves Existing Associations:\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003eThe updated \u003ccode\u003eaddSelectedSongs\u003c/code\u003e method checks if the song or playlist already exists in the relationship before appending. This prevents overwriting existing associations.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eScoped Removal:\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003eThe updated \u003ccode\u003eremoveSong\u003c/code\u003e method only removes the current playlist from the song’s \u003ccode\u003eplaylists\u003c/code\u003e, ensuring other playlist associations remain intact.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eEnsures Data Integrity:\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003eThe changes ensure that a song can belong to multiple playlists simultaneously without any unintended side effects.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e","title":"Resolving update issue for bi-directional relationship models"},{"content":"","permalink":"https://kyxfox.com/ios-apps/my-first-app/","summary":"","title":"My First App"},{"content":"Summary Cross-origin resource sharing (CORS) is a browser mechanism which enables controlled access to resources located outside of a given domain. It extends and adds flexibility to the same-origin policy (SOP).\nAccess-Control-Allow-Origin #ACAO Access-Control-Allow-Origin header is included in the response from one website to a request originating from another website, and identifies the permitted origin of the request.\nGET /data HTTP/1.1 Host: robust-website.com Origin : https://normal-website.com ------------------------------------------------------------------ HTTP/1.1 200 OK ... Access-Control-Allow-Origin: https://normal-website.com Access-Control-Allow-Credentials #ACAC The default behavior of cross-origin resource requests is for requests to be passed without credentials like cookies and the Authorization header. However, the cross-domain server can permit reading of the response when credentials are passed to it by setting the CORS Access-Control-Allow-Credentials header to true.\nGET /data HTTP/1.1 Host: robust-website.com ... Origin: https://normal-website.com Cookie: JSESSIONID=\u0026lt;value\u0026gt; ------------------------------------------------------------------- HTTP/1.1 200 OK ... Access-Control-Allow-Origin: https://normal-website.com Access-Control-Allow-Credentials: true Below is not permitted.\nAccess-Control-Allow-Origin: * Access-Control-Allow-Credentials: true Preventing Proper configuration of cross-origin requests:\nonly allowing trusted sites Avoid whitelisting null Avoid wildcards in internal networks ","permalink":"https://kyxfox.com/posts/cybersecurity/introduction-of-cors/","summary":"\u003ch3 id=\"summary\"\u003eSummary\u003c/h3\u003e\n\u003cp\u003eCross-origin resource sharing (CORS) is a browser mechanism which enables controlled access to resources located outside of a given domain. It extends and adds flexibility to the same-origin policy (SOP).\u003c/p\u003e\n\u003ch4 id=\"access-control-allow-origin\"\u003eAccess-Control-Allow-Origin\u003c/h4\u003e\n\u003cp\u003e#ACAO\n\u003ccode\u003eAccess-Control-Allow-Origin\u003c/code\u003e header is included in the response from one website to a request originating from another website, and identifies the permitted origin of the request.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eGET /data HTTP/1.1\nHost: robust-website.com\nOrigin : https://normal-website.com\n------------------------------------------------------------------\nHTTP/1.1 200 OK\n...\nAccess-Control-Allow-Origin: https://normal-website.com\n\u003c/code\u003e\u003c/pre\u003e\u003ch4 id=\"access-control-allow-credentials\"\u003eAccess-Control-Allow-Credentials\u003c/h4\u003e\n\u003cp\u003e#ACAC\nThe default behavior of cross-origin resource requests is for requests to be passed without credentials like cookies and the Authorization header. However, the cross-domain server can permit reading of the response when credentials are passed to it by setting the CORS \u003ccode\u003eAccess-Control-Allow-Credentials\u003c/code\u003e header to true.\u003c/p\u003e","title":"Introduction of CORS"},{"content":"Summary Cross-site request forgery (also known as CSRF) is a web security vulnerability that allows an attacker to induce users to perform actions that they do not intend to perform. It allows an attacker to partly circumvent the same origin policy, which is designed to prevent different websites from interfering with each other.\nSameSite cookies #SameSite SameSite is a browser security mechanism that determines when a website\u0026rsquo;s cookies are included in requests originating from other websites. In the context of SameSite cookie restrictions, a site is defined as the top-level domain (TLD), usually something like .com or .net, plus one additional level of the domain name. This is often referred to as the TLD+1. When determining whether a request is same-site or not, the URL scheme is also taken into consideration. This means that a link from http://app.example.com to https://app.example.com is treated as cross-site by most browsers.\nSameSite restriction levels: Strict: browsers will not send cookie in any cross-site requests Lax: browsers will send the cookie in cross-site requests, but only if: Request uses the GET method The request resulted from a top-level navigation by the user, such as clicking on a link None: browsers will send this cookie in all requests to the site that issued it Preventing CSRF tokens SameSite cookies Referer-based validation ","permalink":"https://kyxfox.com/posts/cybersecurity/introduction-of-csrf/","summary":"\u003ch3 id=\"summary\"\u003eSummary\u003c/h3\u003e\n\u003cp\u003eCross-site request forgery (also known as CSRF) is a web security vulnerability that allows an attacker to induce users to perform actions that they do not intend to perform. It allows an attacker to partly circumvent the same origin policy, which is designed to prevent different websites from interfering with each other.\u003c/p\u003e\n\u003ch4 id=\"samesite-cookies\"\u003eSameSite cookies\u003c/h4\u003e\n\u003cp\u003e#SameSite\nSameSite is a browser security mechanism that determines when a website\u0026rsquo;s cookies are included in requests originating from other websites.\nIn the context of SameSite cookie restrictions, a site is defined as the top-level domain (TLD), usually something like \u003ccode\u003e.com\u003c/code\u003e or \u003ccode\u003e.net\u003c/code\u003e, plus one additional level of the domain name. This is often referred to as the TLD+1.\nWhen determining whether a request is same-site or not, the URL scheme is also taken into consideration. This means that a link from \u003ccode\u003ehttp://app.example.com\u003c/code\u003e to \u003ccode\u003ehttps://app.example.com\u003c/code\u003e is treated as cross-site by most browsers.\u003c/p\u003e","title":"Introduction of CSRF"}]